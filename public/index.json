[{"content":"I am currently taking the class How To Make Almost Eeverything, and during the professor highlighted the work of former student Jack Forman. He found a way to print textile like materials by under extruding filament to create what he called defeXtiles. By under extruding the filament and building up a wall 1 layer wide, it is possible to make a flexible sheet of plastic. As soon as I saw this unique technique, I knew exactly what I wanted to do this week: I wanted to print clothes. These clothes would also double as my attire to the annual B-3rd ABC party where you have to wear something creative that you made.\nNow it was time to start printing. I knew that I wanted my clothes to look unique and catch the attention of anyone who walked by, so I decided to print with OOVID3D Tri-Color PLA. I \u0026ldquo;designed\u0026rdquo; my print in onshape which you can view here. I use quotation marks because the design only consisted of projecting a helix from a cone to make an Archimedean spiral, giving the spiral some width, and extruding it upwards. I tried to make the spiral width only slightly bigger than the diameter of my nozzle so the Bambu Slicer would print it as one continuous strand. I found it rather amusing that by printing in a spiral you both respected the size constraints of the build plate and made a self supporting structure. Thanks to Gauss’s Theorema Egregium, the same theorem that says to bend your pizza when you eat it so it doesn’t droop, I was sure that the curvature of the spiral would keep the structure supported in the z direction.\nIt was now time to start some test prints! I first needed to figure out what extruder multiplier to use. The paper gave a wide range from 0.7-0.4, but I only started seeing results when I set the extruder multiplier to around 0.4. Maybe this is a quirk of the bambu slicer trying its best to avoid defects in prints, but I never had enough time to fully troubleshoot. I tried extrusion multipliers from as low as 0.2 to as high as 0.45. This was a trade off between flexibility and strength. However with strength also came the tendency to split along layer lines After I printed off these raw materials, it was time to test out if they could be used to make clothes. The easiest thing I could think of to make was a tie. I started by using a clothes iron on low heat to flatten out the material, traced a tie pattern on it, and used a soldering iron to trace along the outline. By using a soldering iron I was both cutting and cauterizing the fabric as I went. I used the soldering iron to put a small hook on the back of each tie so you could wear them with a shirt on. I gave one of the ties I made to a friend for a birthday gift, and he just so happened to have a futuristic costume to go with it. Now it was time to scale up production.\nI again used an iron to flatten out the roll of PLA to a sheet that I could cut. I downloaded a sewing pattern for a waistcoat from freesewing.org and printed it out on some sheets of paper. Throughout the construction I kept running into layer separation. I solved this by placing another pla sheet behind each sheet with layer lines rotated 90 degrees. Overall I do not recommend printing clothes out of PLA. If I could do it again I would have printed everything with TPU which would have been a lot more flexible and forgiving. Now I just need to print out some pants, and I will be ready for the party.\n","permalink":"//localhost:1313/projects/3d_printed_clothes/","summary":"\u003cp\u003eI am currently taking the class How To Make Almost Eeverything, and during the professor highlighted the work of former student Jack Forman. He found a way to print textile like materials by under extruding filament to create what he called \u003ca href=\"https://www.media.mit.edu/publications/defextiles-publication/\"\u003edefeXtiles\u003c/a\u003e. By under extruding the filament and building up a wall 1 layer wide, it is possible to make a flexible sheet of plastic. As soon as I saw this unique technique, I knew exactly what I wanted to do this week: I wanted to print clothes. These clothes would also double as my attire to the annual B-3rd ABC party where you have to wear something creative that you made.\u003c/p\u003e","title":"3D Printed Clothes"},{"content":"This project was made for the De Florez competition. You can check out the poster here. Prompt: \"A dog with sunglasses\"\rProject ideas often come from the most mundane objects. One day an Etch-a-Sketch showed up in my dorm\u0026rsquo;s lounge, and after playing with it for a couple of minutes and creating disappointing images, I had the idea to make it automated. I started talking about the idea with some of my friends, and Elijah Bell said that he wanted to help with the project. In order to give ourselves a deadline, we signed up for the De Florez competition, an annual mechanical engineering competition.\nThe Human Interface One of the first challenges was determining how humans would interface with the device. After bouncing some ideas around we realized that we could use generative AI to make the images. We could then just have a human type in what they want to see, send that request in an API request to DALL-E, and get back an image.\nThe Pathfinding Algorithm Trying to go from an image to connected image\rThe next big challenge was figuring out how to go from an image to a path that you can trace on an Etch-a-Sketch. If we allow backtracking, then the only requirement for an image is that it is connected. In order to try to rectify this every prompt we sent to DALL-E started with \u0026ldquo;Generate a simple image of the following prompt drawn with a single continuous black line without picking up the pen in a line art style. Prompt:.\u0026rdquo; For example, if the user typed in \u0026ldquo;Two stick figures next to each other\u0026rdquo; we would send the prompt:\nGenerate a simple image of the following prompt drawn with a single continuous black line without picking up the pen in a line art style. Prompt: Two stick figures next to each other What we got back from DALL-E\rThis is almost what we want except the heads are disconnected. This inspired us to create this algorithm:\nGet image from Dall-E from instructions + user prompt Convert to Black and White, downscale, find connected components, remove components smaller than 8 pixels. Trace by: Go from the current point (starts at 0,0) to a point in the next component, minimizing white space traveled through by using Dijkstra\u0026rsquo;s algorithm. Add points traveled through to a path array. Depth First Search (DFS) through the component, backtracking with BFS if hitting an end point. Repeat until all components are exhausted Backtracking is important because without it, when the DFS reaches a dead end, we would get random lines drawn across the image\nWith and without backtracking\rThis was particularly difficult to implement, and the algorithm was not very optimized, but we eventually got it working.\nMechanical Design Elijah is a mechanical engineer with scary good CADing skills. He decided to make the drawing robot as sleek as possible and be easily adaptable to any Etch-a-Sketch. You can check out his cad here. We were originally going to try to use rubber bands as belts, but after realizing that this would lead to sloppy drawings due to the flexibility of the bands, we switched to custom belts we printed from 95A TPU. Electrical Design I was responsible for the electrical design and UI. I decided to run everything on a Raspberry Pi Zero 2 W due to its small form factor, wifi connectivity, and computation power. I connected a bluetooth keyboard and OLED display to the pi to allow users to type in their requests. The stepper motors were driven at 12v with A4998 stepper motor drivers. I wanted to anthropomorphize the device, so I even added a little ASCII art character who pretends to draw and has some cute idle animations. You can check out our source code here.\nThe complete part list became:\nRaspberry Pi Zero W Nema 17 Stepper Motor (2x) A4988 Stepper Motor Driver (2x) Lipo Battery PLA frame TPU belts PLA pulleys Steel back plate Mini OLED display Lipo Battery Mini Bluetooth keyboard Etch A Sketch Integration Now came the hardest part of any project: tying it all together. We started by mechanically assembling everything. So far so good.\nNext we tried to draw some squares. Your browser does not support the video tag.\rThis was promising so we tried to draw a picture of a dog. This was a bit too abstract for my taste, and we found a bug in the code that transcribed paths to stepper motor rotations. After fixing this we got a much better result.\nWith this success we tried some other prompts Prompt: \"A cat playing the drums\"\rPrompt: \"Luffy from One Piece\"\rOverall this was a very fun project with a satisfying outcome. While there are still a lot of optimizations that can be made to the design, I am very proud of the final product me and Elijah made.\n","permalink":"//localhost:1313/projects/etch_a_sketch/","summary":"\u003cp\u003eThis project was made for the De Florez competition. You can check out the poster \u003ca href=\"/images/etch_a_sketch/deflorez_poster.pdf\"\u003ehere\u003c/a\u003e.\n\r\n    \u003cfigure\u003e\r\n        \u003cimg src=\"/images/etch_a_sketch/dog_sunglasses.jpg\" alt=\"Image 1\" style=\"width: 50%; height: auto; display: block; margin: 0 auto;\"\u003e\r\n        \u003cfigcaption\u003ePrompt: \"A dog with sunglasses\"\u003c/figcaption\u003e\r\n    \u003c/figure\u003e\r\n\u003c/p\u003e\n\u003cp\u003eProject ideas often come from the most mundane objects. One day an Etch-a-Sketch showed up in my dorm\u0026rsquo;s lounge, and after playing with it for a couple of minutes and creating disappointing images, I had the idea to make it automated. I started talking about the idea with some of my friends, and Elijah Bell said that he wanted to help with the project. In order to give ourselves a deadline, we signed up for the De Florez competition, an annual mechanical engineering competition.\u003c/p\u003e","title":"Automated Etch-a-Sketch"},{"content":"","permalink":"//localhost:1313/projects/cardboard_computer/","summary":"","title":"Cardboard Computer"},{"content":"In the class How to Make Almost Everything, we were tasked with designing a PCB and milling it out. As an electrical engineering major, I found myself in familiar territory. In order to challenge myself and grow my maker toolkit, I decided that I wanted to do this assignment only using a hardware description language to program my board layout and routing rather than doing it manually on Kicad.\nI often find the process of laying out a PCB in CAD tedious, and I feel like I have little control over the geometric constraints between the components on my board. I think it would be great if there existed a PCB design software that implemented basic constraint solving between the footprints of components. With simple length constraints, angle constraints, linear pattern, circular patterns, tangency constraint, and some splines, I feel like the process of board layouts could be easier and more precise than ever. This led me to ask if such a software existed in lecture, and I learned that one of the TAs in the class, Leo McElroy, is working on that right now! He made a software called \u0026ldquo;SVG-PCB\u0026rdquo; that allows you to both graphically place footprints, and also program the placement of the footprints using a hardware description language in java script.\nYou can find the hardware description language code for this board (and more) on my github. I decided to try to make a handheld timing game. This is the PCB I designed.\nComplied from led_circle.js on my github\rI first tried to download my gerber files directly from PCB-SVG, but it did not rotate each LED correctly. I had to download it as a Kicad file, open it in Kicad, and then download the gerber files from Kicad. With this small hiccup solved, I could then let the mill do the heavy lifting of milling my board. It was now time to solder everything on the board. I absolutely love soldering surface mount components with solder paste, so I did this for all the components except for the ATtiny3226 because I was worried about shorting the pins with too much solder paste. I mainly used 1208 sized components, which may look small, but after soldering hundreds of 0805 components on the Solar Car team, 1208 was a breeze.\nI did forget to connect the ground pin of the ATtiny3226 to ground, but this was an easy fix as I only needed to short the ground pin to one of the large unconnect copper sections and then short this copper section to the circular ground track on the edge of the board. Now came the challenge of actually programming the board. I used the Arduino IDE to do this. I downloaded the megaTinyCore in my boards manager, connected an FTDI programmer to the UPDI pin of the ATtiny 3226, wrote a simple blink sketch, and pressed upload. I held my breath as it complied, but I was then hit with the error message \u0026ldquo;a programmer is needed to upload.\u0026rdquo;\nI had the programmer plugged into my computer, and this sent me down a very deep rabbit hole of trying to configure the drivers on my computer and even converting an arduino uno into a jtag programmer because I thought the FTDI programmer was broken. I was about to give up when I saw the option to \u0026ldquo;Upload Using Programmer.\u0026rdquo; I clicked this and an LED started blinking on my board. This was a major facepalm moment, but at least I can now upload programs.\nThe sketch to make the game was not complicated. However, when I tried to run the device off the coin cell battery, the program would randomly restart. I knew that this had to be because the battery could not supply enough current. Thankfully I read in the datasheet that you could make the microcontroller consume less power if you made the internal clock slower. I had the option to reduce the clock speed all the way down to 1MHz, and after this the board worked fine off battery power.\n#define LED_COUNT 14 #define BUTTON_PIN 9 #define START_DELAY 750 const byte leds[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 15 }; unsigned long last_led_move_time = 0; unsigned long last_button_press_time = 0; byte stationary_led = random(0, LED_COUNT); byte moving_led = 0; int move_delay = START_DELAY; bool CCW = false; void setup() { for(byte i = 0; i \u0026lt; LED_COUNT; i++) { pinMode(leds[i], OUTPUT); } pinMode(BUTTON_PIN, INPUT_PULLUP); } void loop() { if(millis()-last_led_move_time \u0026gt;= move_delay) { last_led_move_time = millis(); digitalWrite(leds[moving_led], LOW); switch(CCW) { case true: moving_led = (moving_led + 1) % LED_COUNT; break; case false: moving_led = (moving_led - 1 + LED_COUNT) % LED_COUNT; break; } } digitalWrite(leds[stationary_led], HIGH); digitalWrite(leds[moving_led], HIGH); if(digitalRead(9) == 0) { delay(100); if(moving_led == stationary_led) { digitalWrite(leds[stationary_led], LOW); stationary_led = random(0, LED_COUNT); move_delay = 4*move_delay/5; CCW = !CCW; } else { fail_animation_and_reset(); } while(digitalRead(9) == 0) {} } } void fail_animation_and_reset() { for(byte j = 0; j \u0026lt; 5; j++) { for(byte i = 0; i \u0026lt; LED_COUNT; i++) { digitalWrite(leds[i], HIGH); } delay(300); for(byte i = 0; i \u0026lt; LED_COUNT; i++) { digitalWrite(leds[i], LOW); } delay(300); } move_delay = START_DELAY; } And ta-da, a working game. Your browser does not support the video tag.\rThis was fun to play with for a little while, but then I wanted to up the stakes. Using a MOSFET and one of the free GPIO pins on the ATtiny3226, I make it such that when you lose the game it triggers a high voltage boost converter. Your browser does not support the video tag.\rAfter the success of this board I knew that I could do better. There were some individually accessible neopixels in the maker space, and my first thought was to recreate the game 2048 with a 4x4 grid. I started by programming the layout of the board.\nCompiled from neo_pixel_game.js on my github\rI then milled out the board.\nNext I populated and began programming it just as the last board. You can check out my code here. Finally, I was left with a small, hand held game. I am running the board off two AA batteries. Given the power consumption I measured from a power supply, the AA batteries should be able to power the device continuously for over 50 hours. ","permalink":"//localhost:1313/projects/single_board_games/","summary":"\u003cp\u003eIn the class How to Make Almost Everything, we were tasked with designing a PCB and milling it out. As an electrical engineering major, I found myself in familiar territory. In order to challenge myself and grow my maker toolkit, I decided that I wanted to do this assignment only using a hardware description language to program my board layout and routing rather than doing it manually on Kicad.\u003c/p\u003e\n\u003cp\u003eI often find the process of laying out a PCB in CAD tedious, and I feel like I have little control over the geometric constraints between the components on my board. I think it would be great if there existed a PCB design software that implemented basic constraint solving between the footprints of components. With simple length constraints, angle constraints, linear pattern, circular patterns, tangency constraint, and some splines, I feel like the process of board layouts could be easier and more precise than ever. This led me to ask if such a software existed in lecture, and I learned that one of the TAs in the class, Leo McElroy, is working on that right now! He made a software called \u003ca href=\"https://leomcelroy.com/svg-pcb-website/#/home\"\u003e\u0026ldquo;SVG-PCB\u0026rdquo;\u003c/a\u003e that allows you to both graphically place footprints, and also program the placement of the footprints using a hardware description language in java script.\u003c/p\u003e","title":"Single Board Games"},{"content":"This past summer I had the privelege to bike across the country with MIT Spokes. It was a 74-day student-led trip, starting in Washington, D.C., and ending in San Francisco. Along the way, we stopped at schools, libraries, camps, and even a correctional facility to teach STEM topics based on our personal interests.\nWhen planning my lesson, I knew I wanted it to be as hands-on as possible. I decided to teach about the physics of sound by having each student build their own speaker. From there, I had the task of manufacturing 200 speaker kits for the summer.\nI jumped into Onshape and got to designing. You can check out my CAD here. My main goal was to create a part that would be quick to print in batches and clearly demonstrate the inner workings of a speaker.\nAfter printing the parts, I built the rest of the speaker using a magnet, magnet wire, cardboard, superglue, a Bluetooth audio module, and a custom vinyl sticker that I designed and printed on campus. One of the biggest challenges when making these speakers is creating hand winding the solenoid. Here’s what the finished product looked like:\nNext, it was time to mass-produce the kits. I was lucky enough to have three Bambu Lab X1-Carbon 3D printers at my disposal, allowing me to print 12 speakers per batch. This meant I could make 36 speakers every four hours. Your browser does not support the video tag.\rOnce the prints were complete, I packed the speaker parts into bags with instructions and other materials.\nHere is a minifridge car full of speaker kits for refrence. This was not even all of the kits!\nDuring the MIT Spokes trip, I distributed these kits to students, giving them something to take home. It was incredibly rewarding to see the students\u0026rsquo; excitement when their speakers worked and watch them dance to music. This project made last summer one of the best experiences of my life. This only made saying goodbye to everyone on the team when we reached San Francisco harder.\n","permalink":"//localhost:1313/projects/speaker_kits/","summary":"\u003cp\u003eThis past summer I had the privelege to bike across the country with \u003ca href=\"https://www.mitspokes.com/\"\u003eMIT Spokes\u003c/a\u003e. It was a 74-day student-led trip, starting in Washington, D.C., and ending in San Francisco. Along the way, we stopped at schools, libraries, camps, and even a correctional facility to teach STEM topics based on our personal interests.\u003c/p\u003e\n\u003cp\u003eWhen planning my lesson, I knew I wanted it to be as hands-on as possible. I decided to teach about the physics of sound by having each student build their own speaker. From there, I had the task of manufacturing 200 speaker kits for the summer.\u003c/p\u003e","title":"MIT Spokes Speaker Kits"},{"content":"This was a relatively small and quick project aimed to expose the security risks of NFC tap access doors used at most all universities.\nI began learning how RFID cards work when I found a Proxmark 3 Easy in a maker space, and went down a deep rabbit hole of trying to read the data on every card that I owned. I had great fun doing this and learning about the many different RFID card types. I now collect tap cards like they are pokemon cards.\nIn the same maker space that I found the Proxmark, I also found some arduino compatible NFC modules.\nThese modules are meant to talk to 13.56 MHz MIFARE cards, and my MIT ID card is a MIFARE Classic 1K card. I was surprised to see that I could read the UID of my card with this module, and then emulate this UID on the proxmark to tap into places. I could essentially clone my card. This is a security risk, but I wanted to take it a step farther.\nI built a glove with a hidden card reader. The card reader is on the back of the glove. I imagined that a bad actor could use the glove to brush past someone in the hall and nab their UID. I even added a small motor from a 9g servo motor to vibrate when the glove detected a UID. The code for the project was not difficult to write.\n/* This program will store the UID of all the cards it sees in EEPROM while avoid duplications: EEPROM has 255 addresses for bytes of information. Each UID is 4 bytes. address = 0 will keep track of how many cards we have in the system. */ #include \u0026lt;SPI.h\u0026gt; #include \u0026lt;MFRC522.h\u0026gt; #include \u0026lt;EEPROM.h\u0026gt; #include \u0026lt;Wire.h\u0026gt; #define SS_PIN 10 #define RST_PIN 9 #define MOTOR_PIN 2 MFRC522 mfrc522(SS_PIN, RST_PIN); // Create MFRC522 instance. void setup() { Serial.begin(9600); // Initiate a serial communication SPI.begin(); // Initiate SPI bus mfrc522.PCD_Init(); // Initiate MFRC522 pinMode(MOTOR_PIN, INPUT); } void loop() { // Look for new cards if (Serial.available()) { int cmd = Serial.parseInt(); String dump = \u0026#34;dump\u0026#34;; if (cmd == 1) { //Dump Cards Serial.println(\u0026#34;Dumping Card UIDs...\u0026#34;); for (int i = 0; i \u0026lt; EEPROM.read(0); i++) { unsigned long UID = 0; for (byte j = 1; j \u0026lt;= 4; j++) { Serial.print(EEPROM.read(4 * i + j), HEX); Serial.print(\u0026#34; \u0026#34;); UID += EEPROM.read(4 * i + j) * pow(256, 4 - j); } Serial.print(\u0026#34; \u0026#34;); Serial.print(UID); Serial.println(\u0026#34;\u0026#34;); } } if (cmd == 2) { Serial.println(\u0026#34;Setting Card Count to 0...\u0026#34;); EEPROM.write(0, 0); } Serial.println(\u0026#34;\u0026#34;); } if (!mfrc522.PICC_IsNewCardPresent()) { return; } // Select one of the cards if (!mfrc522.PICC_ReadCardSerial()) { return; } //Show UID on serial monitor String content = \u0026#34;\u0026#34;; byte letter; for (byte i = 0; i \u0026lt; mfrc522.uid.size; i++) { Serial.print(mfrc522.uid.uidByte[i] \u0026lt; 0x10 ? \u0026#34; 0\u0026#34; : \u0026#34; \u0026#34;); Serial.print(mfrc522.uid.uidByte[i], HEX); content.concat(String(mfrc522.uid.uidByte[i] \u0026lt; 0x10 ? \u0026#34; 0\u0026#34; : \u0026#34; \u0026#34;)); content.concat(String(mfrc522.uid.uidByte[i], HEX)); } Serial.println(); bool isDuplicate = false; for (int i = 0; i \u0026lt; EEPROM.read(0); i++) { if (mfrc522.uid.uidByte[0] == EEPROM.read(4 * i + 1) \u0026amp;\u0026amp; mfrc522.uid.uidByte[1] == EEPROM.read(4 * i + 2) \u0026amp;\u0026amp; mfrc522.uid.uidByte[2] == EEPROM.read(4 * i + 3) \u0026amp;\u0026amp; mfrc522.uid.uidByte[3] == EEPROM.read(4 * i + 4)) { isDuplicate = true; //Serial.println(\u0026#34;Duplicate\u0026#34;); } } if (isDuplicate == false) { Serial.println(\u0026#34;New Card Added\u0026#34;); int i = EEPROM.read(0); for (int j = 1; j \u0026lt;= 4; j++) { EEPROM.write(4 * i + j, mfrc522.uid.uidByte[j - 1]); } EEPROM.write(0, i + 1); pinMode(MOTOR_PIN, OUTPUT); delay(500); pinMode(MOTOR_PIN, INPUT); } } This program will save the UIDs that it sees to EEPROM memory, and then I can recover these UIDs later in the serial monitor by sending a \u0026ldquo;1\u0026rdquo;. Once you have a UID, it is possible to emulate that person\u0026rsquo;s card and tap in as them. This project goes to show the major security flaws inherent to a RFID tap system that only checks the UID for identity verification. While it would be hard to design a system that does not suffer from this simple cloning attack, using the rest of the data on the MIFARE Classic 1K card as a means of verification, perhaps in a zero knowledge proof, could help deter this simple attack.\n","permalink":"//localhost:1313/projects/nfc_glove/","summary":"\u003cp\u003eThis was a relatively small and quick project aimed to expose the security risks of NFC tap access doors used at most all universities.\u003c/p\u003e\n\u003cp\u003eI began learning how RFID cards work when I found a Proxmark 3 Easy in a maker space, and went down a deep rabbit hole of trying to read the data on every card that I owned. I had great fun doing this and learning about the many different RFID card types. I now collect tap cards like they are pokemon cards.\u003c/p\u003e","title":"NFC Pen Testing GLove"},{"content":"The inspireation for this project came from my friend from Yale who really likes poetry. When I was talking to him about thermal printers on day, he got the idea to print poems on reciepts. I thought that this was a great idea and immediately hopped into Onshape. I designed a sheet metal enclosure for the device with a 3D printed sign on top encouraging users to press the big red button. You can check out the Onshape cad here.\nThe actual poems are scraped from poetryfoundation.org with beautiful soup because I much prefer to read contemperary poetry rather than older poetry. If you are curious how I did this check it out on my github.\nAfter that I used a raspberry pi 3A to convert the output into serial so I could send it to a thermal printer. Here is a first test.\nAfter some refining I then printed poems like this. I even laser cut out the sheet metal enclosure. It was barely manufacturable and in the future I will make my sheet metal enclosures into more parts to rivet together.\nNow I need to powder coat it, do the electronics, and write the rest of the script. While making this I was also inspired to have the thermal printers print out thousands of digits of constants. During pi day I would love to set some printers up in lobby 7 to print millions of digits of pi.\n","permalink":"//localhost:1313/projects/poetry_robot/","summary":"\u003cp\u003eThe inspireation for this project came from my friend from Yale who really likes poetry. When I was talking to him about thermal printers on day, he got the idea to print poems on reciepts. I thought that this was a great idea and immediately hopped into Onshape. I designed a sheet metal enclosure for the device with a 3D printed sign on top encouraging users to press the big red button. You can check out the Onshape cad \u003ca href=\"https://cad.onshape.com/documents/cf3778deca11ee0736d88359/w/80c19d9216b3187a060b21ef/e/34e68baa4d9532f38bcb4871?renderMode=0\u0026uiState=66f1c5994927d10f4adc73d7\"\u003ehere\u003c/a\u003e.\u003c/p\u003e","title":"Reciept Poetry Printing Robot"}]